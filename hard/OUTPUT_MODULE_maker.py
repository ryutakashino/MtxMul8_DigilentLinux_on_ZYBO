
n = int(input())

import math
# 2つの行列要素と計算開始命令のためのアドレスサイズreg_addr_sizeを求める．
# このセレクタは0から2(n^2)の合計2(n^2)+1個を区別する．2(n^2)を表現可能なビットサイズを求める
reg_addr_size = math.ceil( math.log2(2*n**2 + 1) )    
# この値は4Bの入力データの識別アドレス.ARMからは1Bに1アドレスで送られる．そのため下位2bitを加える。
reg_addr_size +=2;


# 内積結果をoutput_moduleへ格納する際のアドレスサイズselect_sizeを求める．
# このセレクタは0からn^2-1の合計n^2個を区別する．n^2-1を表現可能なビットサイズを求める
select_size = math.ceil( math.log2(n**2) )

 

print("module OUTPUT_MODULE #")
print("    (")
print("		// Width of S_AXI data bus")
print("    parameter integer C_S_AXI_DATA_WIDTH    = 32,")
print("    // Width of S_AXI address bus")
print("    parameter integer C_S_AXI_ADDR_WIDTH	=", reg_addr_size,"")
print("    )(")
print("    input C_START,")

print("    input [",select_size-1,":0] SELECT,", sep='')
print("    input END_SIGNAL,", sep='')
print("    input [C_S_AXI_DATA_WIDTH-1:0] DOT_PRODUCT,")
print("    output [1:0] STATUS,")
print("")
print("    // Global Clock Signal")
print("    input wire  S_AXI_ACLK,")
print("    // Global Reset Signal. This Signal is Active LOW")
print("    input wire  S_AXI_ARESETN,")
print("")
print("    // Read address (issued by master, acceped by Slave)")
print("    input wire [C_S_AXI_ADDR_WIDTH-1:0] S_AXI_ARADDR,")
print("    // Protection type. This signal indicates the privilege")
print("        // and security level of the transaction, and whether the")
print("        // transaction is a data access or an instruction access.")
print("    input wire [2:0] S_AXI_ARPROT,")
print("    // Read address valid. This signal indicates that the channel")
print("        // is signaling valid read address and control information.")
print("    input wire  S_AXI_ARVALID,")
print("    // Read address ready. This signal indicates that the slave is")
print("        // ready to accept an address and associated control signals.")
print("    output wire  S_AXI_ARREADY,")
print("    // Read data (issued by slave)")
print("    output wire [C_S_AXI_DATA_WIDTH-1:0] S_AXI_RDATA,")
print("    // Read response. This signal indicates the status of the")
print("        // read transfer.")
print("    output wire [1:0] S_AXI_RRESP,")
print("    // Read valid. This signal indicates that the channel is")
print("        // signaling the required read data.")
print("    output wire  S_AXI_RVALID,")
print("    // Read ready. This signal indicates that the master can")
print("        // accept the read data and response information.")
print("    input wire  S_AXI_RREADY")
print("    );")
print("")
print("")

print("	// AXI4LITE signals")
print("    reg [C_S_AXI_ADDR_WIDTH-1:0]     axi_araddr;")
print("    reg      axi_arready;")
print("    reg [C_S_AXI_DATA_WIDTH-1:0]     axi_rdata;")
print("    reg [1:0]     axi_rresp;")
print("    reg      axi_rvalid;")
print("")

print("	// ADDR_LSB is used for addressing 32/64 bit registers/memories")
print("	// ADDR_LSB = 2 for 32 bits (n downto 2)")
print("	// ADDR_LSB = 3 for 64 bits (n downto 3)")
print("	localparam integer ADDR_LSB = 2;")
print("	//----------------------------------------------")
print("	//-- Signals for user logic register space example")
print("	//------------------------------------------------")

#内積を格納するレジスタ
for i in range(n**2):
    print("    reg [C_S_AXI_DATA_WIDTH-1:0]	slv_reg", i,";",sep='')

print("  	wire	 slv_reg_rden;")
print("    reg [C_S_AXI_DATA_WIDTH-1:0]     reg_data_out;")
print("")
print("    // I/O Connections assignments")
print("    assign S_AXI_ARREADY    = axi_arready;")
print("    assign S_AXI_RDATA    = axi_rdata;")
print("    assign S_AXI_RRESP    = axi_rresp;")
print("    assign S_AXI_RVALID    = axi_rvalid;    ")
print("   // ***READ***")
print("    // Implement axi_arready generation")
print("    // axi_arready is asserted for one S_AXI_ACLK clock cycle when")
print("    // S_AXI_ARVALID is asserted. axi_awready is ")
print("    // de-asserted when reset (active low) is asserted. ")
print("    // The read address is also latched when S_AXI_ARVALID is ")
print("    // asserted. axi_araddr is reset to zero on reset assertion.")
print("")
print("    always @( posedge S_AXI_ACLK )")
print("    begin")
print("      if ( S_AXI_ARESETN == 1'b0 )")
print("        begin")
print("          axi_arready <= 1'b0;")
print("          axi_araddr  <= 32'b0;")
print("        end ")
print("      else")
print("        begin    ")
print("          if (~axi_arready && S_AXI_ARVALID)")
print("            begin")
print("              // indicates that the slave has acceped the valid read address")
print("              axi_arready <= 1'b1;")
print("              // Read address latching")
print("              axi_araddr  <= S_AXI_ARADDR;")
print("            end")
print("          else")
print("            begin")
print("              axi_arready <= 1'b0;")
print("            end")
print("        end ")
print("    end       ")
print("")
print("    // Implement axi_arvalid generation")
print("    // axi_rvalid is asserted for one S_AXI_ACLK clock cycle when both ")
print("    // S_AXI_ARVALID and axi_arready are asserted. The slave registers ")
print("    // data are available on the axi_rdata bus at this instance. The ")
print("    // assertion of axi_rvalid marks the validity of read data on the ")
print("    // bus and axi_rresp indicates the status of read transaction.axi_rvalid ")
print("    // is deasserted on reset (active low). axi_rresp and axi_rdata are ")
print("    // cleared to zero on reset (active low).  ")
print("    always @( posedge S_AXI_ACLK )")
print("    begin")
print("      if ( S_AXI_ARESETN == 1'b0 )")
print("        begin")
print("          axi_rvalid <= 0;")
print("          axi_rresp  <= 0;")
print("        end ")
print("      else")
print("        begin    ")
print("          if (axi_arready && S_AXI_ARVALID && ~axi_rvalid)")
print("            begin")
print("              // Valid read data is available at the read data bus")
print("              axi_rvalid <= 1'b1;")
print("              axi_rresp  <= 2'b0; // 'OKAY' response")
print("            end   ")
print("          else if (axi_rvalid && S_AXI_RREADY)")
print("            begin")
print("              // Read data is accepted by the master")
print("              axi_rvalid <= 1'b0;")
print("            end")
print("        end")
print("    end")
print("")
print("")


print("     // To show calcuration status")
print("     reg [1:0] status; // IDLE:00, DO:01, END:11")
print("")
print("    // Implement memory mapped register select and read logic generation")
print("    // Slave register read enable is asserted when valid address is available")
print("    // and the slave is ready to accept the read address.")
print("    assign slv_reg_rden = axi_arready & S_AXI_ARVALID & ~axi_rvalid;")
print("    always @(*)")
print("    begin")
print("          // Address decoding for reading registers")

print("	        case ( axi_araddr[C_S_AXI_ADDR_WIDTH-1:ADDR_LSB] )")

for i in range(n**2+1):
    #2nd print ("	      slv_reg",i," <= 0;",sep='');
    output = hex(i)[2:].zfill(-(-reg_addr_size // 4))
    if (i==0):
# reg_addr_size-2が必要なアドレスのbit数．
        print("              ",reg_addr_size-2,"\'h",output,":reg_data_out <= status;",sep='')
    else:
        print("              ",reg_addr_size-2,"\'h",output,": reg_data_out <= slv_reg", i-1 , ";",sep='')

print("              default : reg_data_out <= 32'hFFFF;")
print("          endcase")
print("    end")
print("    ")
print("    // Output register or memory read data")
print("    always @( posedge S_AXI_ACLK )")
print("    begin")
print("      if ( S_AXI_ARESETN == 1'b0 )")
print("        begin")
print("          axi_rdata  <= 0;")
print("        end ")
print("      else")
print("        begin    ")
print("          // When there is a valid read address (S_AXI_ARVALID) with ")
print("          // acceptance of read address by the slave (axi_arready), ")
print("          // output the read dada ")
print("          if (slv_reg_rden)")
print("            begin")
print("              axi_rdata <= reg_data_out;     // register read data")
print("            end   ")
print("        end")
print("    end")
print("")

print("    always @( posedge S_AXI_ACLK )")
print("    begin")
print("        if ( S_AXI_ARESETN == 1'b0 )")
print("        begin")

for i in range(n**2):
    print("	      slv_reg",i," <= 0;",sep='')
print("      end")
print("    else begin")
print("         case (SELECT)")

# 
for i in range(n**2):
    #2nd print ("	      slv_reg",i," <= 0;",sep='');
    # 16進数の桁数は2進数の桁数を4で割って切り上げた数に等しい
    output = hex(i)[2:].zfill(-(-select_size // 4))
    print("	          ",select_size,"\'h",output,": slv_reg", i, " <= DOT_PRODUCT;",sep='')
    #print ("            6'h"'{:>02x}'.format(i), "  : slv_reg", i, " <= DOT_PRODUCT;",sep='');
    
print("            default :;   ")
print("          endcase")
print("        end")
print("    end")
print("   ")
print("    //add 12/24")
print("    always @( posedge S_AXI_ACLK )")
print("    begin")
print("      if ( S_AXI_ARESETN == 1'b0 ) begin")
print("        status  <= 2'b00;")
print("      end else begin")
print("        if (C_START) status <= 2'b01;")
print("        else if (END_SIGNAL) status <= 2'b11;")
print("        else status <= status;")
print("      end")
print("    end")
print("    ")
print("    assign STATUS = status[1:0];")
print("")
print("       ")
print("endmodule")
